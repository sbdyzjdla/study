# 스프링 고급편

### ThreadLocal
싱글톤 객체의 필드나 static 필드와 같이 하나만 존재하는 필드에 
여러 쓰레드가 접근하면 동시성 이슈가 발생할수 있다
이때 ThreadLocal을 사용하면 동시성 이슈를 해결할수있다

쓰레드로컬은 해당 쓰레드만 접근할수있는 저장소다.
Ex) thread-A, thread-B라는 2개의 쓰레드가 있을때 각각 전용 전용 쓰레드 보관소에 값을 저장해 두고 반환해준다

#### ThreadLocal의 주의사항
* WAS처럼 쓰레드풀을 사용하는 환경에서 사용후 ThreadLocal.remove() 함수로 제거해주지 않으면 메모리에 데이터가 계속 남아있어 메모리 누수가 발생할수있다
* 이전 사용자가 thread-A라는 쓰레드를 할당받아 쓰레드 로컬에 데이터를 저장후 제거되지 않았을때 그다음 사용자가 우연히 thread-A를 할당받아 쓰레드 로컬을 조회할경우
현재 사용자는 이전 사용자의 정보를 받게되는 문제가 발생할수도 있다

### 템플릿 메서드 패턴
* 변하지 않는 부분은 부모클래스(추상클래스)에 템플릿 코드를 둔다. 변화하는 부분(비즈니스 로직)은 자식클래스를 만들어서 오버라이딩을 사용해서 처리한다.
* 즉, 부모클래스에 골격인 템플릿을 정의하고 변경되는 로직은 자식 클래스에서 상속과 오버라이딩을 통한 다형성으로 해결함
* 그러나 상속을 사용해서 상속의 단점도 가지고있다. 자식 클래스가 부모클래스에 강결합(부모클래스가 수정되면 자식클래스에도 영향을 줄수있음), 또한 별도의 클래스나 익명클래스를 만들어야 하는 부분도 복잡하다.

### 전략 패턴(Strategy Pattern)
* 템플릿 메서드 패턴과 비슷하면서 상속의 단점을 제거할수 있는 디자인 패턴(상속보다는 인터페이스로 위임)
* 필드 전략 : Context(문맥)은 변하지 않는 로직을 가지고 변하는 부분은 필드로 가지고 있는 strategy 인터페이스의 구현체를 주입하여 사용, 따라서 Strategy가 바뀌어도 Context 코드에는 영향을 주지 않는다. 선조립 후 실행
* 전략을 파라미터로 받는 방식 : Context를 실행하는 시점에 원하는 Strategy를 전달해서 좀더 유연하게 변경할수 있음. 단, 실행할때마다 전략을 계속 지정해 주어야함
* 스프링에서 의존관계 주입에서 사용하는 방식과 같음